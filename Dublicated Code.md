Dublicated Code - дублирующий код.

Симптомы и признаки: возникает, когда одно и то же выражение присутствует в двух методах одного и того же кода.

Причины появления

1. В большинстве случаев дублирование возникает тогда, когда в проекте работает несколько человек, причём над разными его частями. Они работают над похожими задачами, но не знают, что коллега уже написал похожий код, который можно использовать вместо написания своего.
2. Встречается и косвенное дублирование, когда конкретные участки кода отличаются внешне, хотя и выполняют одну и ту же задачу. Такое дублирование бывает довольно сложно обнаружить и исправить.
3. В отдельных случаях дублирование создаётся намеренно. Зачастую, в спешке, когда поджимают сроки сдачи проекта. Начинающий программист видит в уже написанном коде фрагмент, выглядящий «почти так, как нужно» и не может устоять перед соблазном просто скопировать код куда-то в другое место (и так десяток раз).
4. А в самых запущенных случаях программист просто слишком ленив, чтобы избавить код от дублирования.

Лечение

1. Один и тот же участок кода присутствует в двух методах одного и того же класса: необходимо применить <a href="https://github.com/helenasilkina/refactoring/blob/master/Extract_Method%20(Извлечение%20метода).md">извлечение метода</a> и вызывать код созданного метода из обоих участков.
2. Один и тот же участок кода присутствует в двух подклассах, находящихся на одном уровне:

2.1 Необходимо применить <a href="https://github.com/helenasilkina/refactoring/blob/master/Extract_Method%20(Извлечение%20метода).md">извлечение метода</a> для обоих классов с последующим <a href="https://github.com/helenasilkina/refactoring/blob/master/Pull%20Up%20Field%20(Подъём%20поля).md">подъёмом поля</a> для полей, которые используются в поднятом методе.
2.2 Если общий код находится в конструкторе, следует использовать <a href="https://github.com/helenasilkina/refactoring/blob/master/Pull_Up_Constructor_Body%20(Подъём%20тела%20конструктора).md">подъём тела конструктора</a>.
2.3 Если участки кода похожи, но не совпадают полностью, нужно пользоваться <a href="https://github.com/helenasilkina/refactoring/blob/master/Form%20Template%20Method%20(Создание%20шаблонного%20метода).md">созданием шаблонного метода</a>.
2.4 Если оба метода делают одно и то же, но с помощью разных алгоритмов, можно выбрать более чёткий из этих алгоритмов и применить <a href="https://github.com/helenasilkina/refactoring/blob/master/Substitute_Algorithm%20(Замена%20алгоритма).md">замещение алгоритма</a>.
3. Дублирующийся код находится в двух разных классах:
 - Если эти классы не являются частью какой-то иерархии, следует использовать <a href="https://github.com/helenasilkina/refactoring/blob/master/Extract%20Superclass%20(Извлечение%20суперкласса).md">извлечение суперкласса</a>, чтобы создать для интересующих классов один суперкласс, содержащий всю общую функциональность.
 -  Если создание суперкласса нежелательно или невозможно, следует применить <a href="https://github.com/helenasilkina/refactoring/blob/master/Extract%20Class%20(Извлечение%20класса).md">извлечение класса</a> в одном классе, а затем использовать новый компонент в другом.
4. Присутствует череда условных операторов, которые исполняют один и тот же код и отличаются только условиями, следует объединить эти операторы в один с общим условием с помощью <a href="https://github.com/helenasilkina/refactoring/blob/master/Consolidate_Conditional_Expression%20(Объединение%20условных%20операторов).md">объединения условных операторов</a>, а также применить <a href="https://github.com/helenasilkina/refactoring/blob/master/Extract_Method%20(Извлечение%20метода).md">извлечение метода</a>, чтобы вынести это условие в отдельный метод с понятным названием.
5. Один и тот же код выполняется во всех ветках условного оператора: необходимо вынести одинаковый код за пределы условного оператора с помощью <a href="https://github.com/helenasilkina/refactoring/blob/master/Consolidate_Duplicate_Conditional_Fragments%20(Объединение%20дублирующихся%20фрагментов%20в%20условных%20операторах).md">объединения дублирующихся фрагментов в условных операторах</a>.

Выигрыш

1. Объединение дублирующего кода позволяет улучшить структуру кода и уменьшить его объём.
2. Это, в свою очередь, ведёт к упрощению и удешевлению поддержки кода в будущем.

Не стоит трогать, если объединение двух одинаковых участков кода может сделать код менее очевидным и понятным.

