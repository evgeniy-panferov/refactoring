Неуместная близость

Симптомы и признаки: один класс использует служебные поля и методы другого класса.

Причины появления: смотрите внимательно за классами, которые проводят слишком много времени вместе. Хорошие классы должны знать друг о друге как можно меньше. Такие классы легче поддерживать и повторно использовать.

Лечение

1. Самый простой выход — при помощи <a href="https://github.com/helenasilkina/refactoring/blob/master/Move%20Method%20(Перемещение%20метода).md">перемещения метода</a> и <a href="https://github.com/helenasilkina/refactoring/blob/master/Move%20Field%20(Перемещение%20поля).md">перемещения поля</a> перенести части одного класса в другой (в тот, где они используются). Однако это может сработать только в том случае, если оригинальный класс не использует перемещаемые поля и методы.
2. Другим решением является <a href="https://github.com/helenasilkina/refactoring/blob/master/Extract%20Class%20(Извлечение%20класса).md">извлечение зависимых частей в отдельный класс</a> и <a href="https://github.com/helenasilkina/refactoring/blob/master/Hide%20Delegate%20(Сокрытие%20делегирования).md">сокрытие делегирования</a> к этому классу.
3. Если между классами существует обоюдная зависимость, стоит прибегнуть к <a href="https://github.com/helenasilkina/refactoring/blob/master/Change%20Bidirectional%20Association%20to%20Unidirectional%20(Замена%20двунаправленной%20связи%20однонаправленной).md">замене двунаправленной связи на однонаправленную</a>.
4. Если близость возникает между подклассом и родительским классом, рассмотрите возможность <a href="https://github.com/helenasilkina/refactoring/blob/master/Replace%20Delegation%20with%20Inheritance%20(Замена%20делегирования%20наследованием).md">замены делегирования наследованием</a>.

Выигрыш

1. Улучшает организацию кода.
2. Упрощает техническую поддержку и повторное использование кода.
