Большой класс

Симптомы и признаки: класс содержит множество полей/методов/строк кода.

Причины появления

1. Классы редко бывают большими изначально. Но со временем постепенно многие из них «раздуваются» в связи с развитием программы.
2. Как и в случае с длинными методами, чаще всего программисту ментально проще добавить фичу в существующий класс, чем создать новый класс для этой фичи.

Лечение: когда класс реализует слишком обширный функционал, стоит подумать о его разделении:

1. <a href="https://github.com/helenasilkina/refactoring/blob/master/Extract%20Class%20(Извлечение%20класса).md">Извлечение класса</a> поможет, если часть поведения большого класса может быть выделена в свой собственный компонент.
2. <a href="https://github.com/helenasilkina/refactoring/blob/master/Extract%20Subclass%20(Извлечение%20подкласса).md">Извлечение подкласса</a> поможет, если часть поведения большого класса может иметь альтернативные реализации либо используется в редких случаях.
3. <a href="https://github.com/helenasilkina/refactoring/blob/master/Extract%20Interface%20(Извлечение%20интерфейса).md">Извлечение интерфейса</a> поможет, если нужно иметь список операций и поведений, которые клиент сможет использовать.
4. классах графическго интерфейса часто можно найти данные и поведения, которые не относятся к непосредственной отрисовке интерфейса, а скорее отвечают за общую логику работы. Такие данные и поведения следует выделить в отдельный класс предметной области, который бы управлял работой графического интерфейса. При этом может оказаться необходимым хранить копии некоторых данных в двух местах и обеспечить их согласованность. <a href="https://github.com/helenasilkina/refactoring/blob/master/Duplicate%20Observed%20Data%20(Дублирование%20видимых%20данных).md">Дублирование видимых данных</a> предлагает путь, которым можно это осуществить.

Выигрыш

1. Рефакторинг таких классов избавит разработчиков от необходимости запоминать чрезмерное количество имеющихся у класса атрибутов.
2. Во многих случаях разделение больших классов на части позволяет избежать дублирования кода и функциональности.
