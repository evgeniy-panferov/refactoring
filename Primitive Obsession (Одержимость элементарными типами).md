Одержимость элементарными типами

Симптомы и признаки: 

1. Использование элементарных типов вместо маленьких объектов для небольших задач (например, валюта, диапазоны, специальные строки для телефонных номеров и т.п.)
2. Использование констант для кодирования какой-то информации (например, константа USER_ADMIN_ROLE = 1 для обозначения пользователей с ролью администратора).
3. Использование строковых констант в качестве названий полей в массивах.

Причины появления

Как и большинство других запахов, этот начинается с маленькой слабости. Программисту понадобилось поле для хранения каких-то данных. Он подумал, что создать поле элементарного типа куда проще, чем заводить новый класс. Это и было сделано. Потом понадобилось другое поле, и оно было добавлено схожим образом. Не успели оглянуться, как класс уже разросся до грандиозных размеров.

Примитивные типы нередко используются для «симуляции» типов. Это когда вместо отдельного типа данных вы имеете набор чисел или строк, который составляет список допустимых значений для какой-то сущности. Зачастую этим конкретным числам и строкам даются понятные имена с помощью констант, что и является причиной их широкого распространения.

Ещё одним плохим способом использования примитивных типов является «симуляция» полей. При этом класс содержит большой массив разнообразных данных, а в роли индексов массива для получения этих данных используются строковые константы, заданные в классе.

Лечение

1. Если вы имеете множество разнообразных полей примитивных типов, возможно, некоторые из них можно логически сгруппировать и перенести в свой собственный класс. Ещё лучше, если в этот класс вы сможете перенести и поведения, связанные с этими данными. Справиться с этой проблемой поможет замена значения данных объектом.
2. Если значения этих примитивных полей используются в параметрах методов, используйте замену параметров объектом или передачу всего объекта.
3. В случаях, когда в переменных закодированы какие-то сложные данные, используйте замену кодирования типа классом, замену кодирования типа подклассами или замену кодирования типа состоянием/стратегией.
4. Если среди переменных есть массивы, используйте замену массива объектом.

Выигрыш

1. Повышает гибкость кода ввиду использования объектов вместо примитивных типов.
2. Улучшает понимание и организацию кода. Операции над определёнными данными теперь собраны в одном месте, и их не надо искать по всему коду. Теперь не нужно догадываться, зачем созданы все эти странные константы и почему поля содержатся в массиве.
3. Может вскрыть факты дублирования кода.
