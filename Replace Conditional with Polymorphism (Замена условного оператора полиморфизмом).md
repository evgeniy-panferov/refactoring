Замена условного оператора полиморфизмом

Проблема

У вас есть условный оператор, который, в зависимости от типа или свойств объекта, выполняет различные действия.

Решение

Создайте подклассы, которым соответствуют ветки условного оператора. В них создайте общий метод и переместите в него код из соответствующей ветки условного оператора. Впоследствии замените условный оператор на вызов этого метода. Таким образом, нужная реализация будет выбираться через полиморфизм в зависимости от класса объекта.

Пример: <a href="https://github.com/helenasilkina/refactoring/blob/master/Replace_Conditional_with_Polymorphism.py">Replace_Conditional_with_Polymorphism.py</a>

Причины рефакторинга: Этот рефакторинг может помочь, если у вас в коде есть условные операторы, которые выполняют различную работу, в зависимости от:

1. класса объекта или интерфейса, который он реализует;
2. значения какого-то из полей объекта;
3. результата вызова одного из методов объекта.

При этом если у вас появится новый тип или свойство объекта, нужно будет искать и добавлять код во все схожие условные операторы. Таким образом, польза от данного рефакторинга увеличивается, если условных операторов больше одного, и они разбросаны по всем методам объекта.

Достоинства: 
1. Этот рефакторинг реализует принцип говори, а не спрашивай: вместо того, чтобы спрашивать объект о его состоянии, а потом выполнять на основании этого какие-то действия, гораздо проще просто сказать ему, что нужно делать, а как это делать он решит сам.
2. Убивает дублирование кода. Вы избавляетесь от множества почти одинаковых условных операторов.
3. Если вам потребуется добавить новый вариант выполнения, все, что придётся сделать, это добавить новый подкласс, не трогая существующий код (принцип открытости/закрытости).

Порядок рефакторинга

Подготовка к рефакторингу: Чтобы выполнить этот рефакторинг, вам следует иметь готовую иерархию классов, в которых будут содержаться альтернативные поведения. Если такой иерархии ещё нет, нужно создать её. В этом могут помочь другие рефакторинги:

1. Замена кодирования типа подклассами. При этом для всех значений какого-то свойства объекта будут созданы свои подклассы. Это хоть и простой, но менее гибкий способ, т.к. нельзя будет создать подклассы для других свойств объекта.
2. Замена кодирования типа состоянием/стратегией. При этом для определенного свойства объекта будет выделен свой класс и из него созданы подклассы для каждого значения этого свойства. Текущий класс будет содержать ссылки на объекты такого типа и делегировать им выполнение.
3. Последующие шаги этого рефакторинга подразумевают, что вы уже создали иерархию.

Шаги рефакторинга

1. Если условный оператор находится в методе, который выполняет ещё какие-то действия, «извлеките его в новый метод» (Extract method).
2. Для каждого подкласса иерархии, переопределите метод, содержащий условный оператор, и скопируйте туда код соответствующей ветки оператора.
3. Удалите эту ветку из условного оператора.
4. Повторяйте замену, пока условный оператор не опустеет. Затем удалите условный оператор и объявите метод абстрактным.
