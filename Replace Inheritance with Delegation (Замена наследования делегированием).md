<strong>Замена наследования </strong>

Проблема: У вас есть подкласс, который использует только часть методов суперкласса или не хочет наследовать его данные.

Решение: Создайте поле и поместите в него объект суперкласса, делегируйте выполнение методов объекту-суперклассу, уберите наследование.

Причины рефакторинга:

1. Замена наследования композицией может значительно улучшить дизайн классов, если: 
  - Ваш подкласс нарушает принцип замещения Барбары Лисков. Другими словами, наследование возникло только ради объединения общего кода, но не потому, что подкласс «является» (is-a) расширением суперкласса. 
  - Подкласс использует только часть методов суперкласса. В этом случае, это только вопрос времени, пока кто-то не вызовет метод суперкласса, который он не должен был вызывать.
2. Суть рефакторинга сводится к тому, чтобы разделить оба класса, и сделать суперкласс помощником подкласса, а не его родителем. Вместо того чтобы наследовать все методы суперкласса, подкласс будет иметь только необходимые методы, которые будут делегировать выполнение методам объекта-суперкласса.

Достоинства:

1. Класс не содержит лишних методов, которые достались ему в наследство от суперкласса.
2. В поле-делегат можно подставлять разные объекты, имеющие различные реализации функциональности. По сути, вы получаете реализацию паттерна проектирования <a href="https://github.com/helenasilkina/patterns/blob/master/Strategy%20(Стратегия).md">Стратегия</a>.

Недостатки: Приходится писать очень много простых делегирующих методов.

Порядок рефакторинга

1. Создайте поле в подклассе для содержания суперкласса. На первом этапе поместите в него текущий объект.
2. Измените методы подкласса так, чтобы они использовали объект суперкласса, вместо this.
3. Для методов, которые были унаследованы из суперкласса и которые вызывается в клиентском коде, в подклассе нужно создать простые делегирующие методы.
4. Уберите объявление наследования из подкласса.
5. Измените код инициализации поля, в котором хранится бывший суперкласс, созданием нового объекта.
